---
title: "QCreport"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Steps needed to pre-process the data:
- Filtering 
- Imputation
- Normalization - simplest one including log2

```{r}
#data QC
library(FactoMineR)
library(factoextra)
library(limma)
library(ggplot2)
library(plotly)

library(data.table)
library(tidyverse)
```

## Initial description of the data 

```{r}
library(MassExpression)
```

The data contains `r nrow(design)` experiments; the condition of interest has `r length(unique(design))`` levels in the condition of interest. 

## QC functions

```{r}
# this function creates a histogram missingness by protein row
# where missingness is defined as 0 values
protein_missingness_experiment <- function(intensities, design){

  num.samples <- dim(intensities)[2]
  missing.vector <- rowSums(0 == intensities)
  
  missing.vector <- missing.vector/num.samples
  ymax = max(table(missing.vector))#/length(missing.vector)
  
  
  dt = as.data.frame(list(missing.vector = missing.vector))
  p <- ggplot(dt, aes(x = missing.vector)) +
    annotate('rect', xmin = 0.7, xmax = 1.05, ymin = 0, ymax = ymax, alpha=0.2)  +
    geom_histogram(binwidth = max(0.1, round(1/max(num.samples), 2)), fill="skyblue2") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.2),
          panel.grid.major.y = element_blank(),
          panel.border = element_blank(),
          axis.ticks.y = element_blank()
    ) +
    scale_x_continuous("Percentage of measurements per protein", 
                       labels = scales::percent, 
                       limits = c(-0.05, 1.15), 
                       breaks = seq(0, 1, 0.1)) +
    annotate('text', x = 0.5, y = 0.8*ymax, 
             label=str_c("Number of proteins with\nmissing values <= 30%:\n ", sum(missing.vector >= 0.7)))
  
  p
  
}

# this protein plots the number of identifications ??
protein_counts_by_replicate <- function(protein.summarized.experiment){
  
  long <- get_long_protein_intensity(protein.summarized.experiment)

  dt <- long[, .N, by = .(Condition, Replicate)]
  dt[, Replicate := str_c(Condition, Replicate, sep = " - ")]
  p <- ggplot(dt, aes(x = as.factor(Replicate), y = N, color = Condition, label=Replicate)) +
    geom_segment( aes(x=as.factor(Replicate), xend=as.factor(Replicate), y=0, yend=N), color="skyblue") +
    geom_point(size=2, alpha=0.9) +
    coord_flip() +
    theme_minimal() +
    scale_x_discrete("Condition - Replicate") +
    scale_y_continuous("# Identifications") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.2),
          panel.grid.major.y = element_blank(),
          panel.border = element_blank(),
          axis.ticks.y = element_blank()
    )
  
  p
}

# This protein plots the CV distributuions of a protein summarized
# experiment object. Might need to distinguish pre/post workflow versions
plot_protein_cv_distribution <- function(protein.summarized.experiment){
  
  long <- get_long_protein_intensity(protein.summarized.experiment)
  cvdt <- long[, CountRep := .N, by = .(ProteinId, Condition)]
  
  cvdt[, CountRepMax := max(CountRep), by = .(ProteinId, Condition)]
  cvdt[, ReplicatePC := CountRep/CountRepMax]
  cvdt[, Intensity := as.double(Intensity)]
  cvdt <- cvdt[ReplicatePC >= 0.5, .(cv = sd(Intensity)/mean(Intensity)), by = .(ProteinId, Condition)]
  
  p <- ggplot(cvdt, aes(x=cv, fill=Condition, colour=Condition)) +
    geom_density(alpha=0.4) +
    theme_minimal() +
    scale_x_continuous("% CV", labels = scales::percent) +
    ggtitle("Protein Intensity CV")
  
  p
}

# Plots imputed vs not distribution to show how mnar imputation works
plot_imputed_vs_not <- function(prot.int){
  prot.int$Imputed <- as.character(prot.int$Imputed)
  p <- ggplot(prot.int, aes(x=log2NIntNorm, fill=Imputed, 
                            colour = Imputed)) +
    geom_density(alpha=0.4) +
    theme_minimal() +
    ggtitle("Intensity (Imputed vs Not)")
  
  
  p

}

#This shows the intensities by each condition/replicate
plot_measurement_distributions <- function(prot.int, 
                                           use_imputed = F, 
                                           measurement = "log2NInt"){
  
  if (!use_imputed){
    prot.int <- prot.int[Imputed==F]
  }
  
  p <- ggplot(prot.int , aes(x=Replicate, y=get(measurement), fill=Condition, colour=Condition)) +
    geom_boxplot() +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.2),
          panel.grid.major.y = element_blank(),
          panel.border = element_blank(),
          axis.ticks.y = element_blank()
    ) +
    scale_x_discrete("Replicate") +
    scale_y_continuous("Log2 Reporter Intensity")
  
  fig <- ggplotly(p, tooltip = c("y"))%>% config(displayModeBar = T, 
                                                 modeBarButtons = list(list('toImage')),
                                                 displaylogo = F)
  # this code will be needed if you want to make an interactive version
  fig$x$data <- lapply(fig$x$data, FUN = function(x){
    # When creating plot p with ggplot if you specify fill = cut use x$fill$color instead of $line$color
    x$marker$outliercolor = x$line$color 
    # When creating plot p with ggplot if you specify fill = cut use x$fill$color instead $line$color
    x$marker$color = x$line$color
    # When creating plot p with ggplot if you specify fill = cut use x$fill$color instead $line$color
    x$marker$line = x$line$color 
    return(x)
  })
  

  p
}
```

# New functions


```{r rle}
plot_rle_boxplot <- function(intensities, design, log=FALSE){
  
  if(log){
    intensities <- log2(intensities+0.5)
  }
  
  med_rows <- rowMedians(intensities)
  intRLE <- intensities - med_rows
  longIntRLE <- as_tibble(intRLE) %>% pivot_longer(cols = all_of(colnames(intRLE)), 
                                                   names_to = "IntensityColumn", values_to = "intRLE")
  
  longIntRLE <- longIntRLE %>% left_join(design)
  
  p = ggplot(longIntRLE, aes(x = IntensityColumn, y = intRLE)) + 
    geom_boxplot(aes(fill = Condition)) + 
    theme_bw() + 
    geom_hline(yintercept = 0, linetype="dotted") +
    coord_flip()
  p
}
```


```{r}
density_plot <- function(intensities, design, log=FALSE){
  if(log){
    intensities <- log2(intensities+0.5)
  }
  long_int <- as_tibble(intensities) %>% pivot_longer(cols = colnames(intensities), names_to = "exp", values_to = "int")
  p = ggplot(long_int, aes(x = int, fill = exp)) + geom_density(alpha=0.6) + theme_bw()
  p
}
```


```{r imputed-data}

design <- fragpipe_data$design
intensities <- fragpipe_data$intensities

listIntensityExperiments <- runGenericDiscovery(experimentDesign = design, proteinIntensities = intensities)

CompleteIntensityExperiment <- listIntensityExperiments$CompleteIntensityExperiment
IntensityExperiment <- listIntensityExperiments$IntensityExperiment

intensities <- assay(IntensityExperiment)
design <- data.frame(colData(IntensityExperiment))

# mds_plot_experiment(intensities, design)[[1]]
```

```{r}
# mds_plot_experiment(intensities, design)[[2]]
```


```{r}
plot_rle_boxplot(intensities, design)
```

# Data QC


```{r Replicate missingness}
replicate_missingness_experiment1(intensities, design)
```

```{r Protein Missingness}
# not sure why 1 range isn't being rendered
protein_missingness_experiment(IntensityExperiment)
```

```{r}
wide <- as.data.table(assay(protein.summarized.experiment))
wide$ProteinId <- rowData(protein.summarized.experiment)$ProteinId
long <- melt(wide, id.vars = c("ProteinId"), variable.name = "IntensityColumn", value.name = "Intensity")
long <- merge(long, colData(protein.summarized.experiment), by =  "IntensityColumn")
as.data.table(long)
```

```{r Protein Counts}
protein_counts_by_replicate(protein.summarized.experiment)
```

```{r CV Distribution}
plot_protein_cv_distribution(protein.summarized.experiment)
```

### Processing QC

```{r CV Distribution}
plot_protein_cv_distribution(protein.summarized.experiment)
```

```{r Imputation}
plot_imputed_vs_not(prot.int)
```

```{r Measurement Distribution}
plot_measurement_distributions(prot.int)
#plot_measurement_distributions(prot.int, T)
plot_measurement_distributions(prot.int,F, "log2NIntNorm")
plot_measurement_distributions(prot.int, T, "log2NIntNorm")
```


### New QC Concepts:

### Protein Distribution in PCA

Cluster Proteins by Expression

```{r}

res.pca <- PCA((assay(protein.summarized.experiment)), graph = FALSE, ncp = 10)

eig.val <- get_eigenvalue(res.pca)
eig.val <- data.table(dims = rownames(eig.val), eig.val)

samples.pca <- get_pca_ind(res.pca)
samples.coord <- as_data_frame(samples.pca$coord)
#samples.coord$IntensityColumn = colData(protein.summarized.experiment)$IntensityColumn

#samples.coord <- merge(samples.coord, colData(protein.summarized.experiment))
print(colnames(samples.coord))


p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.1, y=Dim.2)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 1 - ", eig.val[dims == "Dim.1", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 2 - ", eig.val[dims == "Dim.2", round(variance.percent,1)], "%"))
p 


p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.2, y=Dim.3)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 2 - ", eig.val[dims == "Dim.2", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 3 - ", eig.val[dims == "Dim.3", round(variance.percent,1)], "%"))
p 

p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.1, y=Dim.2)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 1 - ", eig.val[dims == "Dim.1", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 3 - ", eig.val[dims == "Dim.3", round(variance.percent,1)], "%"))
p 
```

This is clearly the result of missingness which creates clusters in the first dimension. I'm less interested in these clusters so I'll plot the others as well. This is kind of interesting. 

Anyway, I should probably check how the results look after we've normalized and imputed. 

```{r}
colnames(prot.int)

prot.int.tmp <- prot.int[, .(
  ProteinId,
  Condition,
  IntensityColumn,
  log2NIntNorm
)]

prot.int.wide <- dcast(prot.int.tmp, ProteinId ~ IntensityColumn, value.var = "log2NIntNorm")
colnames(prot.int.wide)


res.pca <- PCA(prot.int.wide[,-1], graph = FALSE, ncp = 3)

eig.val <- get_eigenvalue(res.pca)
eig.val <- data.table(dims = rownames(eig.val), eig.val)

samples.pca <- get_pca_ind(res.pca)
samples.coord <- as_data_frame(samples.pca$coord)
#samples.coord$IntensityColumn = colData(protein.summarized.experiment)$IntensityColumn

#samples.coord <- merge(samples.coord, colData(protein.summarized.experiment))
print(colnames(samples.coord))


p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.1, y=Dim.2)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 1 - ", eig.val[dims == "Dim.1", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 2 - ", eig.val[dims == "Dim.2", round(variance.percent,1)], "%"))
p 
```


```{r}
dim(rowData(protein.summarized.experiment))
dim(samples.coord)
dim(prot.int.wide)
samples.coord[,"ProteinId"]= prot.int.wide$ProteinId
colnames(samples.coord)
colnames(rowData(protein.summarized.experiment))
samples.coord <- merge(samples.coord, rowData(protein.summarized.experiment), by = "ProteinId",
                       all.x = T)
colnames(samples.coord)
```

```{r}
library(ggsci)

map2color<-function(x,pal,limits=NULL){
    if(is.null(limits)) limits=range(x, na.rm=T)
    pal[findInterval(x,seq(limits[1],limits[2],length.out=length(pal)+1), all.inside=TRUE)]
}

pal  <- colorRampPalette( c( "blue", "white","red" ) )(100)
map2color(samples.coord$AveExpr, pal)
```

```{r}
library(plotly)
samples.coord <- as_data_frame(samples.coord)
fig <- plot_ly(samples.coord , x = ~Dim.1,  y = ~Dim.2, z = ~Dim.3,
               marker = list(color = ~AveExpr, colorscale = c('#FFE1A1', '#683531'), showscale = TRUE))
fig <- fig %>% add_markers(opacity = 0.5)
fig <- fig %>% layout(scene = list(xaxis = list(title = 'Dim.1'),
                                   yaxis = list(title = 'Dim.2'),
                                   zaxis = list(title = 'Dim.3')))

fig
```




