---
title: "QCreport"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Steps needed to pre-process the data:
- Filtering 
- Imputation
- Normalization - simplest one including log2

```{r}
#data QC
library(FactoMineR)
library(factoextra)
library(limma)
library(ggplot2)
library(plotly)

library(data.table)
library(tidyverse)
```

## Initial description of the data 

```{r}
library(MassExpression)
```


```{r imputed-data}

design <- fragpipe_data$design
intensities <- fragpipe_data$intensities

listIntensityExperiments <- runGenericDiscovery(experimentDesign = design, proteinIntensities = intensities)

CompleteIntensityExperiment <- listIntensityExperiments$CompleteIntensityExperiment
IntensityExperiment <- listIntensityExperiments$IntensityExperiment

intensities <- assay(IntensityExperiment)
design <- data.frame(colData(IntensityExperiment))

# mds_plot_experiment(intensities, design)[[1]]
```


- density plot after imputation and filtering

## QC functions

**protein_counts_by_replicate**: removed as we already had the number of proteins per samples with non zero values. This will just return the same 
number per sample given how we built the long format. 

```{r}
cvdt <- prot_int[Imputed == 0][, countRep := .N, by = .(id, condition)]
cvdt[, countRepMax := max(countRep), by = .(id, condition)]
cvdt[, ReplicatePC := countRep/countRepMax]
cvdt[, intensity := as.double(intensity)]
cvdt <- cvdt[ReplicatePC >= 0.5, .(cv = sd(intensity)/mean(intensity)), by = .(id, condition)]
```


- dispersion versus mean

```{r}
longIntensityDT <- initialiseLongIntensityDT(IntensityExperiment)

plot_protein_cv_distribution <- function(longIntensityDT){
  
    cvdt <- longIntensityDT[Imputed == 0][, countRep := .N, by = .(Replicate, Condition)]
    cvdt[, countRepMax := max(countRep), by = .(Replicate, Condition)]
    cvdt[, ReplicatePC := countRep/countRepMax]
    cvdt[, intensity := as.double(Intensity)]
    cvdt <- cvdt[ReplicatePC >= 0.5, .(cv = sd(intensity)/mean(intensity)), 
                 by = .(Replicate, Condition)]
  
  p <- ggplot(cvdt, aes(x=cv, fill=Condition, colour=Condition)) +
    geom_density(alpha=0.4) +
    theme_minimal() +
    scale_x_continuous("% CV", labels = scales::percent) +
    ggtitle("Protein Intensity CV")
  
  p
}

# This protein plots the CV distributions of a protein summarized
# experiment object. Might need to distinguish pre/post workflow versions

# CV for each protein across conditions

plot_protein_cv_distribution <- function(longIntensityDT){
  
  cvdt <- longIntensityDT %>% group_by(ProteinId, Condition) %>%
    summarise(cv = sd(Intensity)/mean(Intensity), 
              sd = sd(Intensity), 
              m = mean(Intensity))

  p <- ggplot(cvdt, aes(x=cv, fill=Condition, colour=Condition)) +
    geom_density(alpha=0.4) +
    theme_minimal() +
    scale_x_continuous("% CV", labels = scales::percent) +
    ggtitle("Protein Intensity CV")
  
  p
}

# Plots imputed vs not distribution to show how mnar imputation works
plot_imputed_vs_not <- function(prot.int){
  prot.int$Imputed <- as.character(prot.int$Imputed)
  p <- ggplot(prot.int, aes(x=log2NIntNorm, fill=Imputed, 
                            colour = Imputed)) +
    geom_density(alpha=0.4) +
    theme_minimal() +
    ggtitle("Intensity (Imputed vs Not)")
  
  
  p

}

#This shows the intensities by each condition/replicate
plot_measurement_distributions <- function(prot.int, 
                                           use_imputed = F, 
                                           measurement = "log2NInt"){
  
  if (!use_imputed){
    prot.int <- prot.int[Imputed==F]
  }
  
  p <- ggplot(prot.int , aes(x=Replicate, y=get(measurement), fill=Condition, colour=Condition)) +
    geom_boxplot() +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.2),
          panel.grid.major.y = element_blank(),
          panel.border = element_blank(),
          axis.ticks.y = element_blank()
    ) +
    scale_x_discrete("Replicate") +
    scale_y_continuous("Log2 Reporter Intensity")
  
  fig <- ggplotly(p, tooltip = c("y"))%>% config(displayModeBar = T, 
                                                 modeBarButtons = list(list('toImage')),
                                                 displaylogo = F)
  # this code will be needed if you want to make an interactive version
  fig$x$data <- lapply(fig$x$data, FUN = function(x){
    # When creating plot p with ggplot if you specify fill = cut use x$fill$color instead of $line$color
    x$marker$outliercolor = x$line$color 
    # When creating plot p with ggplot if you specify fill = cut use x$fill$color instead $line$color
    x$marker$color = x$line$color
    # When creating plot p with ggplot if you specify fill = cut use x$fill$color instead $line$color
    x$marker$line = x$line$color 
    return(x)
  })
  

  p
}
```

# New functions


```{r rle}
plot_rle_boxplot <- function(intensities, design, log=FALSE){
  
  if(log){
    intensities <- log2(intensities+0.5)
  }
  
  med_rows <- rowMedians(intensities)
  intRLE <- intensities - med_rows
  longIntRLE <- as_tibble(intRLE) %>% pivot_longer(cols = all_of(colnames(intRLE)), 
                                                   names_to = "IntensityColumn", values_to = "intRLE")
  
  longIntRLE <- longIntRLE %>% left_join(design)
  
  p = ggplot(longIntRLE, aes(x = IntensityColumn, y = intRLE)) + 
    geom_boxplot(aes(fill = Condition)) + 
    theme_bw() + 
    geom_hline(yintercept = 0, linetype="dotted") +
    coord_flip()
  p
}
```


```{r}
density_plot <- function(intensities, design, log=FALSE){
  if(log){
    intensities <- log2(intensities+0.5)
  }
  long_int <- as_tibble(intensities) %>% pivot_longer(cols = colnames(intensities), names_to = "exp", values_to = "int")
  p = ggplot(long_int, aes(x = int, fill = exp)) + geom_density(alpha=0.6) + theme_bw()
  p
}
```



```{r}
plot_rle_boxplot(intensities, design)
```

# Data QC


```{r}
wide <- as.data.table(assay(protein.summarized.experiment))
wide$ProteinId <- rowData(protein.summarized.experiment)$ProteinId
long <- melt(wide, id.vars = c("ProteinId"), variable.name = "IntensityColumn", value.name = "Intensity")
long <- merge(long, colData(protein.summarized.experiment), by =  "IntensityColumn")
as.data.table(long)
```

```{r Protein Counts}
protein_counts_by_replicate(IntensityExperiment)
```

```{r CV Distribution}
plot_protein_cv_distribution(protein.summarized.experiment)
```

### Processing QC

```{r CV Distribution}
plot_protein_cv_distribution(protein.summarized.experiment)
```

```{r Imputation}
plot_imputed_vs_not(prot.int)
```

```{r Measurement Distribution}
plot_measurement_distributions(prot.int)
#plot_measurement_distributions(prot.int, T)
plot_measurement_distributions(prot.int,F, "log2NIntNorm")
plot_measurement_distributions(prot.int, T, "log2NIntNorm")
```


### New QC Concepts:

### Protein Distribution in PCA

Cluster Proteins by Expression

```{r}

res.pca <- PCA((assay(protein.summarized.experiment)), graph = FALSE, ncp = 10)

eig.val <- get_eigenvalue(res.pca)
eig.val <- data.table(dims = rownames(eig.val), eig.val)

samples.pca <- get_pca_ind(res.pca)
samples.coord <- as_data_frame(samples.pca$coord)
#samples.coord$IntensityColumn = colData(protein.summarized.experiment)$IntensityColumn

#samples.coord <- merge(samples.coord, colData(protein.summarized.experiment))
print(colnames(samples.coord))


p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.1, y=Dim.2)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 1 - ", eig.val[dims == "Dim.1", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 2 - ", eig.val[dims == "Dim.2", round(variance.percent,1)], "%"))
p 


p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.2, y=Dim.3)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 2 - ", eig.val[dims == "Dim.2", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 3 - ", eig.val[dims == "Dim.3", round(variance.percent,1)], "%"))
p 

p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.1, y=Dim.2)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 1 - ", eig.val[dims == "Dim.1", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 3 - ", eig.val[dims == "Dim.3", round(variance.percent,1)], "%"))
p 
```

This is clearly the result of missingness which creates clusters in the first dimension. I'm less interested in these clusters so I'll plot the others as well. This is kind of interesting. 

Anyway, I should probably check how the results look after we've normalized and imputed. 

```{r}
colnames(prot.int)

prot.int.tmp <- prot.int[, .(
  ProteinId,
  Condition,
  IntensityColumn,
  log2NIntNorm
)]

prot.int.wide <- dcast(prot.int.tmp, ProteinId ~ IntensityColumn, value.var = "log2NIntNorm")
colnames(prot.int.wide)


res.pca <- PCA(prot.int.wide[,-1], graph = FALSE, ncp = 3)

eig.val <- get_eigenvalue(res.pca)
eig.val <- data.table(dims = rownames(eig.val), eig.val)

samples.pca <- get_pca_ind(res.pca)
samples.coord <- as_data_frame(samples.pca$coord)
#samples.coord$IntensityColumn = colData(protein.summarized.experiment)$IntensityColumn

#samples.coord <- merge(samples.coord, colData(protein.summarized.experiment))
print(colnames(samples.coord))


p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.1, y=Dim.2)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 1 - ", eig.val[dims == "Dim.1", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 2 - ", eig.val[dims == "Dim.2", round(variance.percent,1)], "%"))
p 
```


```{r}
dim(rowData(protein.summarized.experiment))
dim(samples.coord)
dim(prot.int.wide)
samples.coord[,"ProteinId"]= prot.int.wide$ProteinId
colnames(samples.coord)
colnames(rowData(protein.summarized.experiment))
samples.coord <- merge(samples.coord, rowData(protein.summarized.experiment), by = "ProteinId",
                       all.x = T)
colnames(samples.coord)
```

```{r}
library(ggsci)

map2color<-function(x,pal,limits=NULL){
    if(is.null(limits)) limits=range(x, na.rm=T)
    pal[findInterval(x,seq(limits[1],limits[2],length.out=length(pal)+1), all.inside=TRUE)]
}

pal  <- colorRampPalette( c( "blue", "white","red" ) )(100)
map2color(samples.coord$AveExpr, pal)
```

```{r}
library(plotly)
samples.coord <- as_data_frame(samples.coord)
fig <- plot_ly(samples.coord , x = ~Dim.1,  y = ~Dim.2, z = ~Dim.3,
               marker = list(color = ~AveExpr, colorscale = c('#FFE1A1', '#683531'), showscale = TRUE))
fig <- fig %>% add_markers(opacity = 0.5)
fig <- fig %>% layout(scene = list(xaxis = list(title = 'Dim.1'),
                                   yaxis = list(title = 'Dim.2'),
                                   zaxis = list(title = 'Dim.3')))

fig
```




