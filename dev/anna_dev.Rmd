---
title: "anna_dev"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r}
ls("package:MassExpression")
outputFolder <- "data-raw"
```


```{r}
fp_exp <- design_fragpipe
fp_proteins <- assay_fragpipe
```


```{r}
uploadParser <- function(uploadFolder){
  proteinIntensities <- read.table(file.path(uploadFolder, "protein_intensities.tsv"), sep = "\t", stringsAsFactors = F)
  experimentDesign <- read.table(file.path(uploadFolder, "experiment_design.tsv"), sep = "\t",  stringsAsFactors = F)
  list(proteinIntensities=proteinIntensities, experimentDesign=experimentDesign)
}
```


# Run example end-to-end

```{r}
IntensityExperiment <- runGenericDiscovery(experimentDesign = sample_data_diann, proteinIntensities = assay_diann)
writeOutput(IntensityExperiment, outputFolder)
```


```{r End to End Pipeline}

# This function performs the log2 conversion and writes the imputed column
prepare_prot_int <- function(protein.summarized.experiment){
  prot.int <- get_long_protein_intensity(protein.summarized.experiment)
  stopifnot(dim(prot.int)[1]>0)
  prot.int <- as.data.table(prot.int)
  prot.int[, Imputed := 0L]
  prot.int[Intensity == 0, Imputed := 1L]
  prot.int[, log2NInt := 0.0]
  prot.int[Intensity > 0 , log2NInt := log2(Intensity)]
  
  prot.int 
}

# This function orchestrates imputation, normalization and the binary limma 
# statistics accross all experimental comparisons
runLimmaPipeline <- function(protein.summarized.experiment){
  
  
  prot.int <- prepare_prot_int(protein.summarized.experiment)
  
  # Create Median Normalized Measurements in each Condition/Replicate
  prot.int[Imputed == F, log2NIntNorm := log2NInt - median(log2NInt), by = list(Condition,Replicate)]
  
  # Imputation
  prot.int <- impute_lfq(prot.int, 
                         id_type = "ProteinId", 
                         int_type = "log2NIntNorm",
                         f_imputeStDev = 0.3,
                         f_imputePosition= 1.8)
  

  # RunId will be unique to a row wherease replicate may not
  prot.int[, RunId := str_c(Condition, Replicate, sep = ".")]
  
  #Run LIMMA
  results.quant <- limma_stats_fun(ID_type = "ProteinId",
                                   int_type = "log2NIntNorm",
                                   condition_col_name = "Condition",
                                   run_id_col_name = "RunId",
                                   rep_col_name = "Replicate",
                                   funDT = prot.int)
  
  rowData(protein.summarized.experiment) = merge(rowData(protein.summarized.experiment), 
                                                 results.quant, by = "ProteinId", all.x = T)
  
  
  
  list(protein.summarized.experiment,prot.int)
}


```


```{r limma stats function}

library(Biobase)
library(limma)
library(data.table)

limma_stats_fun <- function(ID_type,
                            int_type,
                            condition_col_name,
                            run_id_col_name,
                            rep_col_name,
                            funDT,
                            pairwise.comp = NULL,
                            all.comparisons = TRUE,
                            fix_distr = FALSE) {


  if (all.comparisons) {
    comination_mat <- combn(x = funDT[, unique(get(condition_col_name))], 2)
    pairwise.comp <- foreach (i = 1:ncol(comination_mat)) %do% {
      return(data.table(
        left = comination_mat[1,i],
        right = comination_mat[2,i]
      ))
    }
    pairwise.comp <- rbindlist(pairwise.comp)
  }


  funDT <- funDT[str_order(get(run_id_col_name), numeric = T)]
  funDT[, ID := str_c("ID.", get(ID_type))]

  # Filter for IDs that are not present in at least one experiment
  filterDT <- unique(funDT[, .(get(condition_col_name), get(run_id_col_name))])[, .(max_count = .N), by = .(V1)]
  filterDT <- merge(funDT, filterDT, by.x = condition_col_name, by.y = "V1", all.x = T)
  filterDT <- filterDT[Imputed == 0, .(count_rep = .N, 
                                       max_count = max(max_count, na.rm = T)), 
                       by = c(condition_col_name, "ID")][, repPC := count_rep/max_count]

  isPresent <- filterDT[repPC >= 0.5, unique(ID)]
  funDT <- funDT[ID %in% isPresent]

  fun.formula <- as.formula(str_c("ID ~ ", run_id_col_name))


  int_matrix <-
    dcast.data.table(funDT, fun.formula, value.var = int_type)
  int_matrix <- int_matrix[str_order(ID, numeric = T)]
  intrawnames <- int_matrix[, ID]
  intcolnames <- colnames(int_matrix[, 2:ncol(int_matrix)])
  intcolnames <- str_sort(intcolnames, numeric = TRUE)

  int_matrix <- as.matrix(int_matrix[, intcolnames, with = FALSE])
  rownames(int_matrix) <- intrawnames

  ### Imputed value mask matrix ------
  imputed_matrix <-
    dcast.data.table(funDT, fun.formula, value.var = "Imputed")
  imputed_matrix <- imputed_matrix[str_order(ID, numeric = T)]
  imp_mat_rawnames <- imputed_matrix[, ID]
  imp_mat_colnames <- colnames(imputed_matrix[, 2:ncol(imputed_matrix)])
  imp_mat_colnames <- str_sort(imp_mat_colnames, numeric = TRUE)

  imputed_matrix <- as.matrix(imputed_matrix[, imp_mat_colnames, with = FALSE])
  rownames(imputed_matrix) <- imp_mat_rawnames
  isZ <- imputed_matrix == 1

  sample_dt <- as.data.frame(unique(funDT[, .(
    run_id = get(run_id_col_name),
    condition = get(condition_col_name),
    Replicate = get(rep_col_name)
  )]))
  rownames(sample_dt) <- sample_dt$run_id
  
  
  feature_dt <- data.frame(ID = rownames(int_matrix), otherinfo = NA)

  rownames(feature_dt) <- feature_dt$ID

  # Create ExpressionSet object
  eset <- ExpressionSet(
    assayData = int_matrix,
    phenoData = AnnotatedDataFrame(sample_dt),
    featureData = AnnotatedDataFrame(feature_dt)
  )

  design.mat <- model.matrix(~ 0 + condition,
                             data = pData(eset))
  myContrasts = NULL
  for (irow in 1:pairwise.comp[, .N]) {
    left <- pairwise.comp[irow, left]
    right <- pairwise.comp[irow, right]

    myContrasts = c(myContrasts,
                    str_c("condition", left, " - ", "condition", right))
  }


  contrast.matrix <- eval(as.call(c(
    as.symbol("makeContrasts"),
    as.list(myContrasts),
    levels = list(design.mat)
  )))

  fit <- lmFit(eset, design.mat)

  # exper.cond <- "UPS1"
  # fix_distr <- TRUE
  if (fix_distr) {
    for (exper.cond in pairwise.comp[, c(left, right)]) {
      Runs <- pData(eset)[pData(eset)$condition == exper.cond, run_id_col_name]
      i <- which(rowSums(isZ[,colnames(isZ) %in% Runs]) == length(Runs))
      eset_fix <- exprs(eset[i,])
      eset_fix[,colnames(isZ) %in% Runs] <- NA
      fit3 <- lmFit(eset_fix, design.mat)
      fit$sigma[i] <- fit3$sigma
      fit$df.residual[i] <- fit3$df.residual
    }
  }
  fit2 <- contrasts.fit(fit, contrasts = contrast.matrix)
  fit2 <- eBayes(fit2, robust = TRUE, trend = TRUE)

  stats <-
    topTable(fit2,
             number = nrow(fit2),
             sort.by = "none"
    )
  stats <- as.data.table(stats)
  stats <- stats[, .(ID, AveExpr, F, adj.P.Val)]
  #ipair = 1
  #### pairwise comparisons
  for (ipair in 1:pairwise.comp[, .N]) {
    #print(ipair)
    subsecting <- funDT[get(condition_col_name) %in% pairwise.comp[ipair, c(left, right)], unique(get(run_id_col_name))]

    # Filter for IDs that are not present in at least one experiment in pairwise manner
    isPresent <- filterDT[get(condition_col_name) %in% pairwise.comp[ipair, c(left, right)] & repPC >= 0.5, unique(ID)]

    if (length(isPresent) > 0) {
      eset_pair <- eset[rownames(eset) %in% isPresent, colnames(eset) %in% subsecting]



      design.mat <- model.matrix(~ 0 + condition,
                                 data = pData(eset_pair))


      myContrasts = NULL
      left <- pairwise.comp[ipair, left]
      right <- pairwise.comp[ipair, right]
      myContrasts = c(myContrasts,
                      str_c("condition", left, " - ", "condition", right))
      contrast.matrix <- eval(as.call(c(
        as.symbol("makeContrasts"),
        as.list(myContrasts),
        levels = list(design.mat)
      )))

      fit <- lmFit(eset_pair, design.mat)
      fit2 <- contrasts.fit(fit, contrasts = contrast.matrix)
      fit2 <- eBayes(fit2, robust = TRUE, trend = TRUE)

      s_dt <-
        as.data.table(topTable(
          fit2,
          number = nrow(fit2),
          sort.by = "p",
          confint = 0.95,
          coef = myContrasts
        ))
      s_dt <- s_dt[, .(ID, logFC, CI.L, CI.R, P.Value, adj.P.Val)]
      #q_vals <- qvalue(s_dt[, P.Value])
      #s_dt[, Q.Value := q_vals$qvalues]

      comparison <- str_replace_all(myContrasts, "condition", "")
      colnames(s_dt)[colnames(s_dt) != "ID"] <-
        str_c(colnames(s_dt)[colnames(s_dt) != "ID"], comparison, sep = " ")
      stats <- merge(stats, s_dt, by = "ID", all = T)
    }


  }





  stats[, ID := str_replace_all(ID, "ID.", "")]
  setnames(stats, "ID", ID_type)
  return(stats)
}
```

```{r impute LFQ data func}
#' 
#'
#' This function does MNAR imputation
#'
#' @param myQuantDT quantification data
#' @param id_type the id column of myQuantDT that indicates
#' @param int_type the column of myQuantDT to be imputed
#' @param f_imputStDev The Standard Deviation parameter for MNAR Imputation
#' @param f_imputePosition The Position parameter for MNAR Imputation
#' @return quantification data with missing values imputed
#' @examples
#'  dt_int <- impute_lfq(myQuantDT = dt_int,
#'  id_type = "id",
#'  int_type = "log2NInt", #log2Intensity
#'  0.3,
#'  1.8,
#'  )
#' @export impute_lfq
impute_lfq <- function(myQuantDT,
                       id_type,
                       int_type,
                       f_imputeStDev = imputeStDev,
                       f_imputePosition = imputePosition) {

  myQuantDT[, int_impute := get(int_type)]
  myQuantDT <- myQuantDT[, colnames(myQuantDT) != int_type, with = F]
  impute.StdDev <-
    f_imputeStDev * myQuantDT[Imputed == 0, sd(int_impute)]
  impute.position <-
    myQuantDT[Imputed == 0, mean(int_impute)] - f_imputePosition * myQuantDT[Imputed == 0, sd(int_impute)]
  set.seed(255)
  myQuantDT[Imputed == 1, int_impute := rnorm(.N, (impute.position), (impute.StdDev))]

  # Add columns for centered and centered + scaled intensities
  myQuantDT[, nRLE := scale(int_impute, center = TRUE, scale = FALSE), by = .(get(id_type))]
  myQuantDT[, z_norm := scale(int_impute, center = TRUE, scale = TRUE), by = .(get(id_type))]

  setnames(myQuantDT, "int_impute", int_type)

  return(myQuantDT)
}
```


```{r Utilities}

# This function converts the assay data in a protein intensity se
# to a long data.table object with intensities for each protein Id and intensity
# column
get_long_protein_intensity <- function(protein.summarized.experiment){
  wide <- as.data.table(assay(protein.summarized.experiment))
  colnames(wide) <- protein.summarized.experiment$IntensityColumn
  wide$ProteinId <- rowData(protein.summarized.experiment)$ProteinId
  long <- melt(wide, id.vars = c("ProteinId"), variable.name = "IntensityColumn", value.name = "Intensity")
  long <- merge(long, colData(protein.summarized.experiment), by =  "IntensityColumn")
  as.data.table(long)
}

#long <- get_long_protein_intensity(protein.summarized.experiment)
#long

```



