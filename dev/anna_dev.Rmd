---
title: "anna_dev"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
uploadParser <- function(uploadFolder){
  proteinIntensities <- read.table(file.path(uploadFolder, "protein_intensities.tsv"), sep = "\t", stringsAsFactors = F)
  experimentDesign <- read.table(file.path(uploadFolder, "experiment_design.tsv"), sep = "\t",  stringsAsFactors = F)
  list(proteinIntensities=proteinIntensities, experimentDesign=experimentDesign)
}
```


```{r}
ls("package:MassExpression")
```

## QC

### Data QC

```{r clustering}
pca_plot_experiment(protein.summarized.experiment)
```

```{r Replicate missingness}
replicate_missingness_experiment(protein.summarized.experiment)
```

```{r Protein Missingness}
# not sure why 1 range isn't being rendered
protein_missingness_experiment(protein.summarized.experiment)
```

```{r}
wide <- as.data.table(assay(protein.summarized.experiment))
wide$ProteinId <- rowData(protein.summarized.experiment)$ProteinId
long <- melt(wide, id.vars = c("ProteinId"), variable.name = "IntensityColumn", value.name = "Intensity")
long <- merge(long, colData(protein.summarized.experiment), by =  "IntensityColumn")
as.data.table(long)
```

```{r Protein Counts}
protein_counts_by_replicate(protein.summarized.experiment)
```

```{r CV Distribution}
plot_protein_cv_distribution(protein.summarized.experiment)
```

### Processing QC

```{r CV Distribution}

plot_protein_cv_distribution(protein.summarized.experiment)
```

```{r Imputation}


plot_imputed_vs_not(prot.int)

```

```{r Measurement Distribution}
plot_measurement_distributions(prot.int)
#plot_measurement_distributions(prot.int, T)
plot_measurement_distributions(prot.int,F, "log2NIntNorm")
plot_measurement_distributions(prot.int, T, "log2NIntNorm")
```

### New QC Concepts:

### Protein Distribution in PCA
Cluster Proteins by Expression

```{r}

res.pca <- PCA((assay(protein.summarized.experiment)), graph = FALSE, ncp = 10)

eig.val <- get_eigenvalue(res.pca)
eig.val <- data.table(dims = rownames(eig.val), eig.val)

samples.pca <- get_pca_ind(res.pca)
samples.coord <- as_data_frame(samples.pca$coord)
#samples.coord$IntensityColumn = colData(protein.summarized.experiment)$IntensityColumn

#samples.coord <- merge(samples.coord, colData(protein.summarized.experiment))
print(colnames(samples.coord))


p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.1, y=Dim.2)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 1 - ", eig.val[dims == "Dim.1", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 2 - ", eig.val[dims == "Dim.2", round(variance.percent,1)], "%"))
p 


p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.2, y=Dim.3)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 2 - ", eig.val[dims == "Dim.2", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 3 - ", eig.val[dims == "Dim.3", round(variance.percent,1)], "%"))
p 

p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.1, y=Dim.2)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 1 - ", eig.val[dims == "Dim.1", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 3 - ", eig.val[dims == "Dim.3", round(variance.percent,1)], "%"))
p 
```

This is clearly the result of missingness which creates clusters in the first dimension. I'm less interested in these clusters so I'll plot the others as well. This is kind of interesting. 

Anyway, I should probably check how the results look after we've normalized and imputed. 

```{r}
colnames(prot.int)

prot.int.tmp <- prot.int[, .(
  ProteinId,
  Condition,
  IntensityColumn,
  log2NIntNorm
)]

prot.int.wide <- dcast(prot.int.tmp, ProteinId ~ IntensityColumn, value.var = "log2NIntNorm")
colnames(prot.int.wide)


res.pca <- PCA(prot.int.wide[,-1], graph = FALSE, ncp = 3)

eig.val <- get_eigenvalue(res.pca)
eig.val <- data.table(dims = rownames(eig.val), eig.val)

samples.pca <- get_pca_ind(res.pca)
samples.coord <- as_data_frame(samples.pca$coord)
#samples.coord$IntensityColumn = colData(protein.summarized.experiment)$IntensityColumn

#samples.coord <- merge(samples.coord, colData(protein.summarized.experiment))
print(colnames(samples.coord))


p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.1, y=Dim.2)) +
  stat_ellipse(geom = "polygon", alpha=0.1) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_x_continuous(str_c("PCA 1 - ", eig.val[dims == "Dim.1", round(variance.percent,1)], "%")) +
  scale_y_continuous(str_c("PCA 2 - ", eig.val[dims == "Dim.2", round(variance.percent,1)], "%"))
p 
```


```{r}
dim(rowData(protein.summarized.experiment))
dim(samples.coord)
dim(prot.int.wide)
samples.coord[,"ProteinId"]= prot.int.wide$ProteinId
colnames(samples.coord)
colnames(rowData(protein.summarized.experiment))
samples.coord <- merge(samples.coord, rowData(protein.summarized.experiment), by = "ProteinId",
                       all.x = T)
colnames(samples.coord)
```

```{r}
library(ggsci)

map2color<-function(x,pal,limits=NULL){
    if(is.null(limits)) limits=range(x, na.rm=T)
    pal[findInterval(x,seq(limits[1],limits[2],length.out=length(pal)+1), all.inside=TRUE)]
}

pal  <- colorRampPalette( c( "blue", "white","red" ) )(100)
map2color(samples.coord$AveExpr, pal)
```

```{r}
library(plotly)
samples.coord <- as_data_frame(samples.coord)
fig <- plot_ly(samples.coord , x = ~Dim.1,  y = ~Dim.2, z = ~Dim.3,
               marker = list(color = ~AveExpr, colorscale = c('#FFE1A1', '#683531'), showscale = TRUE))
fig <- fig %>% add_markers(opacity = 0.5)
fig <- fig %>% layout(scene = list(xaxis = list(title = 'Dim.1'),
                                   yaxis = list(title = 'Dim.2'),
                                   zaxis = list(title = 'Dim.3')))

fig
```



## Write Output Tables
## Protein Viz
## Counts and Intensities

[
	{
		"ProteinGroupId": "100",
		"ProteinId": "O35593",
		"GeneName": "Psmd14",
		"ProteinDescription": "26S proteasome non-ATPase regulatory subunit 14",
		"FastaHeaders": "sp|O35593|PSDE_MOUSE 26S proteasome non-ATPase regulatory subunit 14 OS=Mus musculus OX=10090 GN=Psmd14 PE=1 SV=2",
		"ProteinQValue": 0,
		"ProteinScore": 10.73,
		"conditions": [
			{
				"name": "Cerebellum",
				"precentageOfReplicates": 0.5,
				"numberOfReplicateCount": 4,
				"intensityValues": [
					{
						"replicateNum": 1,
						"centeredIntensity": 0.749918461968428,
						"z_norm": 0.894384217678135,
						"log2NInt_ProteinGroupId": -2.96634794751,
						"Imputed": 0
					},
					{
						"replicateNum": 2,
						"centeredIntensity": 0.647910901219001,
						"z_norm": 0.772725721394879,
						"log2NInt_ProteinGroupId": -3.07935607412021,
						"Imputed": 0
					},
					

This json has some complex structure:
- list of proteins (with info)
  - contains a list of conditions (with info)
    - containes a list of measurements


here's how we're going to do this, we're going to first learn how to write dataframes inside others in R then use json lite to write the dataframe

```{r}
colnames(prot.int)
```

```{r}
prot.int <- results[[2]]

prot.int$Number = 1
prot.int = prot.int %>%
    group_by(ProteinId, Condition) %>%
    mutate(replicateNum = cumsum(Number))
prot.int <- as.data.table(prot.int)


tmp <- function(x){
  names(x) = c("replicateNum","z_norm","log2NIntNorm", "Imputed")
  #unlist(x)
  x
}
prot.int[, intensityValues := lapply(transpose(.(replicateNum,z_norm,log2NIntNorm, Imputed)), tmp)]
#prot.int$intensityValues[1]


prot.int = prot.int %>% group_by(ProteinId, Condition) %>% 
  summarise(replicateNum = length(Imputed),
            percentageOfReplicates = (sum(Imputed == F)/length(Imputed)),
            intensityValues = list(intensityValues))
colnames(prot.int)
prot.int = prot.int %>% group_by(ProteinId) %>% 
  summarise(
    name = Condition, 
    percentageOfReplicates = percentageOfReplicates,
    condition = list(
      replicateNum = replicateNum, 
      intensityValues = 1)
  )

write_json(prot.int,"test2.json", digits = NA, na = "null")
```

```{r}
prot.int %>% group_by(ProteinId, Condition, Replicate) %>%
  summarise(intensityValues = log2NIntNorm)
```

```{r}
prot.int %>% group_by(ProteinId, Condition) %>% 
  summarise(
    replicateNum = (numberOfReplicateCount),
    percentageOfReplicates = (sum(Imputed == F)/length(Imputed)))
```

```{r}
experiment.design[experiment.design$Condition == 'Kidney',]
```





## End to End Pipeline:


```{r outside of function}

#upload_folder = "/home/joseph/experiments/frag_pipe_test/"
#output_folder = "/home/joseph/experiments/frag_pipe_test/transform"

#IO 
#protein.intensities <- read.table(file.path(upload_folder, "protein_intensities.tsv"), sep = "\t", stringsAsFactors = F)
#experiment.design <- read.table(file.path(upload_folder, "experiment_design.tsv"), sep = "\t", stringsAsFactors = F)

# Create Data Rep
protein.summarized.experiment <- construct_summarized_experiment(experiment.design, protein.intensities)

# Get Binary Statistic Comparisons and Long for Protein Intensity
results <- run_binary_limma_pipeline(protein.summarized.experiment)
protein.summarized.experiment <- results[[1]]
prot.int <- results[[2]]

# Construct Single Object with Update data
complete.protein.summarized.experiment <-
  get_complete_protein_summarized_experiment(protein.summarized.experiment,
                                             prot.int)

# Write Discovery Outputs
write_protein_viz(output_folder, protein.summarized.experiment)
```

```{r plot to check LIMMA is working}

plot_volcano <- function(comparison.statistics){
  p <- ggplot(comparison.statistics, 
              aes(FoldChange, -log10(AdjustedPValue), fdr = AdjustedPValue, ProteinId = ProteinId)) + 
    geom_point() +
    geom_hline(yintercept=-log10(0.05)) 
  ggplotly(p)
}

comparison = "remission - ulcer"
comparison.statistics <- rowData(protein.summarized.experiment)
comparison.statistics <- filter_stats_table_on_comparison(comparison.statistics, comparison)
comparison.statistics <- fill_out_missing_columns(comparison.statistics)
comparison.statistics <- rename_comparison_statistics_export(comparison.statistics)
plot_volcano(comparison.statistics)

# seems like it's working, can tweak later as needed
```

```{r Check Examples}

upload_folder = "/home/joseph/experiments/frag_pipe_test/"
run_generic_discovery(upload_folder, file.path(upload_folder,"transform"))

upload_folder = "/home/joseph/experiments/PD_test/"
run_generic_discovery(upload_folder, file.path(upload_folder,"transform"))

upload_folder = "/home/joseph/github_repos/LFQProcessing/acceptance_test_data/TMT/pxd_019880_mouse/"
run_generic_discovery(upload_folder, "universal_importer_test")

upload_folder = "/home/joseph/experiments/PD_test/"
run_generic_discovery(upload_folder, "universal_importer_test")

upload_folder = "/home/joseph/experiments/Spectronaught/"
run_generic_discovery(upload_folder, "universal_importer_test")
```

## Check LIMMA results mouse dataset

```{r}

upload_folder = "/home/joseph/github_repos/LFQProcessing/acceptance_test_data/TMT/pxd_019880_mouse/"
#IO 
protein.intensities <- read.table(file.path(upload_folder, "protein_intensities.tsv"), sep = "\t", stringsAsFactors = F)
experiment.design <- read.table(file.path(upload_folder, "experiment_design.tsv"), sep = "\t", stringsAsFactors = F)

# Create Data Rep
protein.summarized.experiment <- construct_summarized_experiment(experiment.design, protein.intensities)

# Get Binary Statistic Comparisons and Long for Protein Intensity
results <- run_binary_limma_pipeline(protein.summarized.experiment)
protein.summarized.experiment <- results[[1]]
prot.int <- results[[2]]

plot_volcano <- function(comparison.statistics){
  p <- ggplot(comparison.statistics, 
              aes(FoldChange, -log10(AdjustedPValue), fdr = AdjustedPValue, ProteinId = ProteinId)) + 
    geom_point() +
    geom_hline(yintercept=-log10(0.05)) 
  ggplotly(p)
}

comparison = "Kidney - Cerebellum"
comparison.statistics <- rowData(protein.summarized.experiment)
comparison.statistics <- filter_stats_table_on_comparison(comparison.statistics, comparison)
comparison.statistics <- fill_out_missing_columns(comparison.statistics)
comparison.statistics <- rename_comparison_statistics_export(comparison.statistics)
plot_volcano(comparison.statistics)

```

## Hook Up Enrichment using RData

```{r}
library(EnrichmentAnalysisStepR)
```

Trying to create a 2 condition enrichment step input

```{r}
colnames(rowData(complete.protein.summarized.experiment))
```

```{r}

comparison.protein.summarized.experiment <- 
  create_enrichment_comparison(complete.protein.summarized.experiment,
                             "Kidney - Cerebellum")

# What we want to do is run
enrichment.table <- perform_comparison_enrichment(comparison.protein.summarized.experiment,
                              "/home/joseph/github_repos/enrichment-step/gene_sets/10090",
                              method = "camera")
```

```{r}

plot_enr_volcano <- function(enr_table){
  p <- ggplot(enr_table, 
              aes(afc, -log10(adj.pval), fdr = adj.pval, color = observed, gene.set = gene.set)) + 
    geom_point() +
    geom_hline(yintercept=-log10(0.05)) 
  ggplotly(p)
}

plot_enr_volcano(enrichment.table$Reactome)
```


# Functions


## Plotting

```{r}
# This is useful just for checking results.
plot_volcano <- function(comparison.statistics){
  p <- ggplot(comparison.statistics, 
              aes(FoldChange, -log10(AdjustedPValue), fdr = AdjustedPValue, ProteinId = ProteinId)) + 
    geom_point() +
    geom_hline(yintercept=-log10(0.05)) 
  ggplotly(p)
}
```


## End of Workflow Construct Export Object

I realized that being ready to write proteinz viz wasn't the same as being ready to do enrichment or write protein counts and intensities or QC. Here's a couple functions 
and an orchestrator that could bring it all together.

```{r}

# count the imputatatiosn in each condition and write to wide table
get_imputed_counts <- function(prot.int){
  imputed.counts <- prot.int %>% group_by(ProteinId, Condition) %>%
    summarize(NImputed = sum(Imputed))
  imputed.counts <- dcast(imputed.counts, ProteinId ~ Condition, value.var = "NImputed")
  colnames(imputed.counts)[-1] <- str_c("Imputed: ", colnames(imputed.counts)[-1])
  imputed.counts
}

# count the replicates in each condition and write to wide table
get_replicate_counts <- function(prot.int){
  replicate.counts <- prot.int %>% group_by(ProteinId, Condition) %>%
    summarize(NReplicates= sum(Imputed==0)+sum(Imputed==1))
  replicate.counts <- dcast(replicate.counts, ProteinId ~ Condition, value.var = "NReplicates")
  colnames(replicate.counts)[-1] <- str_c("Replicates: ", colnames(replicate.counts)[-1])
  replicate.counts
}

# adds prot.int information to protein.summarized experiment with statistics
# to deliver fully contained experiment object
get_complete_protein_summarized_experiment <- function(protein.summarized.experiment, prot.int){
  
  complete.protein.summarized.experiment <- protein.summarized.experiment
    
  # replaceIntensity with missing values to normalized log scale with imputed values
  prot.int.wide <- dcast(prot.int, ProteinId ~ IntensityColumn, value.var = "log2NIntNorm")
  assay(complete.protein.summarized.experiment) <- prot.int.wide[,-1]

  
  # add imputed and replicate counts to the final object
  imputed.counts <- get_imputed_counts(prot.int)
  rowData(complete.protein.summarized.experiment) <- merge(rowData(complete.protein.summarized.experiment),
                                                           imputed.counts, by = "ProteinId", all.x = T)
  
  replicate.counts <- get_replicate_counts(prot.int)
  rowData(complete.protein.summarized.experiment) <- merge(rowData(complete.protein.summarized.experiment),
                                                           replicate.counts, by = "ProteinId", all.x = T)

  complete.protein.summarized.experiment
}

```


