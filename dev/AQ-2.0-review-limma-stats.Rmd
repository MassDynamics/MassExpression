---
title: "review-limma-stats"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
design <- fragpipe_data$design
intensities <- fragpipe_data$intensities
parameters <- fragpipe_data$parameters
normalisation_method <- parameters[parameters[,1] == "UseNormalisationMethod",2]
species <- parameters[parameters[,1] == "Species",2]
labellingMethod <- parameters[parameters[,1] == "LabellingMethod",2]

listMetadata <- list(Species = species, 
                     LabellingMethod = labellingMethod, 
                     NormalisationAppliedToAssay = "None")

# Create Data Rep
IntensityExperiment <- createSummarizedExperiment(experimentDesign = design, 
                                                     proteinIntensities = intensities, 
                                                     listMetadata = listMetadata)

```


```{r}
longIntensityDT <- initialiseLongIntensityDT(IntensityExperiment)
NormalisationMethod = "None"

# Create Median Normalized Measurements in each Condition/Replicate
if (NormalisationMethod == "Median"){
  longIntensityDT[Imputed == F, log2NIntNorm := log2NInt - median(log2NInt), by = list(Condition,Replicate)]
}else if(NormalisationMethod == "None") {
  longIntensityDT[, log2NIntNorm := log2NInt]
} else {
  stop(paste0("Normalisation method ",NormalisationMethod," not availble."))
}

# Imputation
longIntensityDT <- imputeLFQ(longIntensityDT, 
                       id_type = "ProteinId", 
                       int_type = "log2NIntNorm",
                       f_imputeStDev = 0.3,
                       f_imputePosition= 1.8)

# RunId will be unique to a row wherease replicate may not
longIntensityDT[, RunId := stringr::str_c(Condition, Replicate, sep = ".")]
```

```{r eval=FALSE}
# Run LIMMA
resultsQuant <- limmaStatsFun(ID_type = "ProteinId",
                                 int_type = "log2NIntNorm",
                                 condition_col_name = "Condition",
                                 run_id_col_name = "RunId",
                                 rep_col_name = "Replicate",
                                 funDT = longIntensityDT)
stats = resultsQuant[["stats"]]
conditionComparisonMapping = resultsQuant[["conditionComparisonMapping"]]
```



```{r}
library(data.table)
library(stringr)

ID_type = "ProteinId"
int_type = "log2NIntNorm"
condition_col_name = "Condition"
run_id_col_name = "RunId" # condition and replicate
rep_col_name = "Replicate"
funDT = longIntensityDT
pairwise.comp = NULL
all.comparisons = TRUE
fix_distr = FALSE
```

* Do we need to do all the pairwise comparisons?

```{r limmaStats-pairwise}
# 1. all possible comparisons
if (all.comparisons) {
   comination_mat <- combn(x = funDT[, unique(get(condition_col_name))], 2)
   # we don't need to parallelize this one
  pairwise.comp <- foreach (i = 1:ncol(comination_mat), .packages="foreach") %do% {
    return(data.table(
      left = comination_mat[1,i],
      right = comination_mat[2,i]
    ))
  }
  pairwise.comp <- rbindlist(pairwise.comp)
}


funDT <- funDT[str_order(get(run_id_col_name), numeric = T)]

## do we need this ID??
funDT[, ID := str_c("ID.", get(ID_type))]
```


- At this stage, the data could be stored in the summarised experiment object or DGE list needed for limma  - use `filterByExpr` in edgeR which takes a summarised experiment in input
- Concept of library size in proteomics is not the same?

```{r limmaStats-filter}
# Filter for IDs that are not present in at least one experiment

# 1. N replicates in each condition group
filterDT <- unique(funDT[, .(get(condition_col_name), get(run_id_col_name))])[, .(max_count = .N), by = .(V1)]

# 2. Merge number of replicates in each group
filterDT <- merge(funDT, filterDT, by.x = condition_col_name, by.y = "V1", all.x = T)

# 3. Only look at non-imputed values - tell me for each protein , for each condition , how many replicates are available
filterDT <- filterDT[Imputed == 0, .(count_rep = .N, 
                                     max_count = max(max_count, na.rm = T)), 
                     by = c(condition_col_name, "ID")][, repPC := count_rep/max_count]

# 4. For each protein, we require at least 505 of the samples to have available data
isPresent <- filterDT[repPC >= 0.5, unique(ID)]
funDT <- funDT[ID %in% isPresent]

# 5. funDT = filtered data
```

The filtering done here is as follows:
- Keep a protein if it is present in at least 50% of one group of the condition of interest

This means that a protein is kept if it is present in one group but absent completely from other 2 groups (for example). 
This method of filtering motivates the extra filtering done in each pairwise comparison. 
It would be better if filtering was done once for all. 

Filtering each pairwise comparison means that we are then performing as many different related models as we have pairwise comparisons but we are not adjusting for the multiple testing. Doing one model instead of different ones is the reason why we do ANOVA instead of many t-tests. 




```{r prepare-int-matrix}
fun.formula <- as.formula(str_c("ID ~ ", run_id_col_name))

int_matrix <-
  dcast.data.table(funDT, fun.formula, value.var = int_type)
int_matrix <- int_matrix[str_order(ID, numeric = T)]
intrawnames <- int_matrix[, ID]
intcolnames <- colnames(int_matrix[, 2:ncol(int_matrix)])
intcolnames <- str_sort(intcolnames, numeric = TRUE)

int_matrix <- as.matrix(int_matrix[, intcolnames, with = FALSE])
rownames(int_matrix) <- intrawnames

### Imputed value mask matrix ------
imputed_matrix <-
  dcast.data.table(funDT, fun.formula, value.var = "Imputed")
imputed_matrix <- imputed_matrix[str_order(ID, numeric = T)]
imp_mat_rawnames <- imputed_matrix[, ID]
imp_mat_colnames <- colnames(imputed_matrix[, 2:ncol(imputed_matrix)])
imp_mat_colnames <- str_sort(imp_mat_colnames, numeric = TRUE)

imputed_matrix <- as.matrix(imputed_matrix[, imp_mat_colnames, with = FALSE])
rownames(imputed_matrix) <- imp_mat_rawnames
isZ <- imputed_matrix == 1
```

```{r prepare-samples-data}
sample_dt <- as.data.frame(unique(funDT[, .(
  run_id = get(run_id_col_name),
  condition = get(condition_col_name),
  Replicate = get(rep_col_name)
)]))
rownames(sample_dt) <- sample_dt$run_id
```

```{r prepare-features-data}
feature_dt <- data.frame(ID = rownames(int_matrix), otherinfo = NA)

rownames(feature_dt) <- feature_dt$ID
```


```{r prepare-eset}
# Create ExpressionSet object
eset <- ExpressionSet(
  assayData = int_matrix,
  phenoData = AnnotatedDataFrame(sample_dt),
  featureData = AnnotatedDataFrame(feature_dt)
)
```


- What is fix-ditribution for?

```{r full-model}
design.mat <- model.matrix(~ 0 + condition,
                           data = pData(eset))
myContrasts = NULL

condition_seperator = "-"

for (irow in 1:pairwise.comp[, .N]) {
  left <- pairwise.comp[irow, left]
  right <- pairwise.comp[irow, right]
  
  newContrast <- str_c("condition",left, condition_seperator, "condition",right)
  myContrasts = c(myContrasts, newContrast)
}


conditionComparisonMapping <- assembleComparisonConditionMapping(
  pairwise.comp, 
  seperator = condition_seperator
  )


contrast.matrix <- eval(as.call(c(
  as.symbol("makeContrasts"),
  as.list(myContrasts),
  levels = list(design.mat)
)))

fit <- lmFit(eset, design.mat)

# exper.cond <- "UPS1"
# fix_distr <- TRUE
if (fix_distr) {
  for (exper.cond in pairwise.comp[, c(left, right)]) {
    Runs <- pData(eset)[pData(eset)$condition == exper.cond, run_id_col_name]
    i <- which(rowSums(isZ[,colnames(isZ) %in% Runs]) == length(Runs))
    eset_fix <- exprs(eset[i,])
    eset_fix[,colnames(isZ) %in% Runs] <- NA
    fit3 <- lmFit(eset_fix, design.mat)
    fit$sigma[i] <- fit3$sigma
    fit$df.residual[i] <- fit3$df.residual
  }
}
fit2 <- contrasts.fit(fit, contrasts = contrast.matrix)
fit2 <- eBayes(fit2, robust = TRUE, trend = TRUE)

stats <-
  topTable(fit2,
           number = nrow(fit2),
           sort.by = "none", coef = "conditioncontrol-conditionrecurrence"
  )
stats <- as.data.table(stats)
stats <- stats[, .(ID, AveExpr, F, adj.P.Val)]
```


```{r}
dt <- decideTests(fit2)
Global.Adjusted.P <- fit2$p.value
Global.Adjusted.P[] <- p.adjust(Global.Adjusted.P, method="BH")
```


- Is this subsetting column names `pairwise.comp[ipair, c(left, right)]`?

```{r all-compare}
#ipair = 1
#### pairwise comparisons
for (ipair in 1:pairwise.comp[, .N]) {
  
  # funDT contains everything
  # filterDT has been filtered
  subsecting <- funDT[get(condition_col_name) %in% pairwise.comp[ipair, c(left, right)], unique(get(run_id_col_name))]
  
  # Filter for IDs that are not present in at least one experiment in pairwise manner
  isPresent <- filterDT[get(condition_col_name) %in% pairwise.comp[ipair, c(left, right)] & repPC >= 0.5, unique(ID)]
  
  if (length(isPresent) > 0) {
    eset_pair <- eset[rownames(eset) %in% isPresent, colnames(eset) %in% subsecting]
    
    
    
    design.mat <- model.matrix(~ 0 + condition,
                               data = pData(eset_pair))
    
    
    myContrasts = NULL
    left <- pairwise.comp[ipair, left]
    right <- pairwise.comp[ipair, right]
    myContrasts = c(myContrasts,
                    str_c("condition",left, "-", "condition",right))
    contrast.matrix <- eval(as.call(c(
      as.symbol("makeContrasts"),
      as.list(myContrasts),
      levels = list(design.mat)
    )))
    
    fit <- lmFit(eset_pair, design.mat)
    fit2 <- contrasts.fit(fit, contrasts = contrast.matrix)
    fit2 <- eBayes(fit2, robust = TRUE, trend = TRUE)
    
    s_dt <-
      as.data.table(topTable(
        fit2,
        number = nrow(fit2),
        sort.by = "p",
        confint = 0.95,
        coef = myContrasts
      ))
    s_dt <- s_dt[, .(ID, logFC, CI.L, CI.R, P.Value, adj.P.Val)]
    #q_vals <- qvalue(s_dt[, P.Value])
    #s_dt[, Q.Value := q_vals$qvalues]
    
    comparison <- str_replace_all(myContrasts, "condition", "")
    colnames(s_dt)[colnames(s_dt) != "ID"] <-
      str_c(colnames(s_dt)[colnames(s_dt) != "ID"], comparison, sep = " ")
    stats <- merge(stats, s_dt, by = "ID", all = T)
  }
  
  
}

stats[, ID := str_replace_all(ID, "ID.", "")]
setnames(stats, "ID", ID_type)
```

