---
title: "Joseph Dev"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# preprocessings
library(tidyverse)
library(stringr)
library(data.table)

# data model
library(SummarizedExperiment)

#data QC
library(FactoMineR)
library(factoextra)
library(limma)
library(ggplot2)
library(plotly)

library(foreach)
```

# Imports

```{r}
construct_summarized_experiment <- function(experiment.design, protein.intensities){
  
  
  stopifnot("Condition" %in% colnames(experiment.design))
  stopifnot("Replicate" %in% colnames(experiment.design))
  stopifnot("IntensityColumn" %in% colnames(experiment.design))
  
  stopifnot(all(experiment.design$IntensityColumn %in% colnames(protein.intensities)))
  stopifnot("ProteinId" %in% colnames(protein.intensities))
  
  
  row.data.possible=  c("ProteinId","GeneId","Description")
  row.data.present = intersect(row.data.possible, colnames(protein.intensities))
  row.data.absent <- row.data.possible[!(row.data.possible %in% row.data.present)]
  
  assay.data = as.matrix(protein.intensities[,experiment.design$IntensityColumn])
  row.data = protein.intensities[,row.data.present] 
  row.data[,row.data.absent]<-NA
  
  # construct summarized experiment object
  summarized.experiment <- SummarizedExperiment(rowData = row.data,
                                          assays= SimpleList(counts=assay.data),
                                          colData = experiment.design)
    
  summarized.experiment
}

```


## Max Quant 

```{r}
experiment_home = "~/github_repos/LFQProcessing/acceptance_test_data/LFQ/iPRG2015/"

protein.intensities = read.csv(file.path(experiment_home, "proteinGroups.txt"), sep = "\t", stringsAsFactors = F)

colnames(protein.intensities)

protein.id.column = NULL
protein.ids.column = "Majority.protein.IDs"
gene.id.column = NULL
details.column = "Fasta.headers"
description.id.column = NULL

# deal with majority.protien.ids

protein.intensities[[protein.ids.column]]


```


## Frag Pipe

- combined proteins has protein intensities
- 

```{r frag_pipe_parser}

experiment_home = "~/experiments/frag_pipe_test/"

protein.intensities = read.csv(file.path(experiment_home, "combined_protein.tsv"), sep = "\t", stringsAsFactors = F)

cols <- colnames(protein.intensities)[grepl("Total.Intensity", colnames(protein.intensities))]
runs <- gsub(".Total.Intensity", "", cols)
groups <- gsub("_[0-9]*$","",runs)

experiment.design <-as_data_frame(cbind(cols,runs,groups))
colnames(experiment.design) <- c("IntensityColumn", "Replicate", "Condition")
experiment.design

protein.id.column = "Protein.ID"
gene.id.column = "Gene.Names"
description.id.column = "Description"

protein.intensities = protein.intensities[,c(protein.id.column,
                                             gene.id.column,
                                             description.id.column,
                                             experiment.design$IntensityColumn)]

protein.intensities = protein.intensities %>% 
  rename(
    ProteinId = protein.id.column,
    GeneId = gene.id.column,
    Description = description.id.column
  )

protein.summarized.experiment = construct_summarized_experiment(experiment.design, protein.intensities)

```


## PD

```{r}
# this is stuff the app does
experiment_home = "~/experiments/PD_test"

protein.intensities = read.csv(file.path(experiment_home, "iPRG-no_clustering-no_mbr_Proteins.txt"), sep = "\t", stringsAsFactors = F)

cols <- colnames(protein.intensities)[grepl("apQuant.Area.", colnames(protein.intensities))]
runs <- gsub("apQuant.Area.", "", cols)
groups <- str_extract(runs,"sample[0-9]")

experiment.design <-as_data_frame(cbind(cols,runs,groups))
colnames(experiment.design) <- c("IntensityColumn", "Replicate", "Condition")
experiment.design

protein.id.column = "Accession"
gene.id.column = NULL
description.id.column = "Description"

protein.intensities = protein.intensities[,c(protein.id.column,
                                             gene.id.column,
                                             description.id.column,
                                             experiment.design$IntensityColumn)]
protein.intensities = protein.intensities %>% 
  rename(
    ProteinId = protein.id.column,
    GeneId = gene.id.column,
    Description = description.id.column
  )

protein.summarized.experiment = construct_summarized_experiment(experiment.design, protein.intensities)

```

1. Intensity. ProteinId (GeneId, Description). Experiment Design. 
2. 1. + 
3.

A. Long Data


# QC

- clustering
- missingness
- distributions (log or no log, bias)

```{r clustering}

pca_plot_experiment <- function(protein.summarized.experiment){
  
  res.pca <- PCA(t(assay(protein.summarized.experiment)), graph = FALSE, ncp = 2)
  
  eig.val <- get_eigenvalue(res.pca)
  eig.val <- data.table(dims = rownames(eig.val), eig.val)
  
  samples.pca <- get_pca_ind(res.pca)
  samples.coord <- as_data_frame(samples.pca$coord)
  samples.coord$IntensityColumn = colnames(protein.summarized.experiment)
  
  samples.coord <- merge(samples.coord, colData(protein.summarized.experiment))
  print(colnames(samples.coord))
  
  
  p <- ggplot(as_data_frame(samples.coord), aes(x = Dim.1, y=Dim.2, colour=Condition, fill=Condition, label=Replicate)) +
    stat_ellipse(geom = "polygon", alpha=0.1) +
    geom_point(size = 3, alpha = 0.7) +
    theme_minimal() +
    scale_x_continuous(str_c("PCA 1 - ", eig.val[dims == "Dim.1", round(variance.percent,1)], "%")) +
    scale_y_continuous(str_c("PCA 2 - ", eig.val[dims == "Dim.2", round(variance.percent,1)], "%"))
  
  ggplotly(p)
  
}

pca_plot_experiment(protein.summarized.experiment)
```

Let's try to get the percentage of missingness by protein (histogram) and by run/condition (bar)

```{r Replicate missingness}

replicate_missingness_experiment <- function(protein.summarized.experiment){
  

  missing.vector <- colSums(0 == (assay(protein.summarized.experiment)))
  missing.table <- as_data_frame(cbind(names(missing.vector), missing.vector))
  colnames(missing.table) <- c("IntensityColumn", "MissingValues")
  missing.table <- merge(missing.table, colData(protein.summarized.experiment))
  missing.table <- as_data_frame(missing.table)
  missing.table
  
  p <- ggplot(missing.table, aes(x = Replicate, y = as.numeric(MissingValues), color = Condition, label=as.factor(Replicate))) +
    geom_segment( aes(x= Replicate, xend= Replicate, y=0, yend=as.numeric(MissingValues)), color="skyblue") +
    geom_point(size=2, alpha=0.9) +
    coord_flip() +
    theme_minimal() +
    scale_x_discrete("Replicate") +
    scale_y_continuous("# Missing Values") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.2),
          panel.grid.major.y = element_blank(),
          panel.border = element_blank(),
          axis.ticks.y = element_blank()
          )
  p
  
}

replicate_missingness_experiment(protein.summarized.experiment)
```

```{r Protein Missingness}
# not sure why 1 range isn't being rendered

protein_missingness_experiment <- function(protein.summarized.experiment){

  num.replicates <- dim(assay(protein.summarized.experiment))[2]
  
  missing.vector <- rowSums(0 == (assay(protein.summarized.experiment)))
  missing.vector <- missing.vector/num.replicates
  ymax = max(table(missing.vector))#/length(missing.vector)
  
  
  dt = as.data.frame(list(missing.vector = missing.vector))
  p <- ggplot(dt, aes(x = missing.vector)) +
    annotate('rect', xmin = 0.7, xmax = 1.05, ymin = 0, ymax = ymax, alpha=0.2)  +
    geom_histogram(binwidth = max(0.1, round(1/max(num.replicates), 2)), fill="skyblue2") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.2),
          panel.grid.major.y = element_blank(),
          panel.border = element_blank(),
          axis.ticks.y = element_blank()
    ) +
    scale_x_continuous("Percentage of measurements per protein", 
                       labels = scales::percent, 
                       limits = c(-0.05, 1.15), 
                       breaks = seq(0, 1, 0.1)) +
    annotate('text', x = 0.5, y = 0.8*ymax, 
             label=str_c("Number of proteins with\nmissing values <= 30%:\n ", sum(missing.vector >= 0.7)))
  
  p
  
}

protein_missingness_experiment(protein.summarized.experiment)
```

```{r Utility get long}

get_long_protein_intensity <- function(protein.summarized.experiment){
  wide <- as.data.table(assay(protein.summarized.experiment))
  wide$ProteinId <- rowData(protein.summarized.experiment)$ProteinId
  long <- melt(wide, id.vars = c("ProteinId"), variable.name = "IntensityColumn", value.name = "Intensity")
  long <- merge(long, colData(protein.summarized.experiment), by =  "IntensityColumn")
  as.data.table(long)
}

long <- get_long_protein_intensity(protein.summarized.experiment)
long

```

```{r CV Distribution}

plot_protein_cv_distribution <- function(protein.summarized.experiment){
  
  long <- get_long_protein_intensity(protein.summarized.experiment)
  cvdt <- long[, CountRep := .N, by = .(ProteinId, Condition)]
  
  cvdt[, CountRepMax := max(CountRep), by = .(ProteinId, Condition)]
  cvdt[, ReplicatePC := CountRep/CountRepMax]
  cvdt[, Intensity := as.double(Intensity)]
  cvdt <- cvdt[ReplicatePC >= 0.5, .(cv = sd(Intensity)/mean(Intensity)), by = .(ProteinId, Condition)]
  
  p <- ggplot(cvdt, aes(x=cv, fill=Condition, colour=Condition)) +
    geom_density(alpha=0.4) +
    theme_minimal() +
    scale_x_continuous("% CV", labels = scales::percent) +
    ggtitle("Protein Intensity CV")
  
  p
}

plot_protein_cv_distribution(protein.summarized.experiment)
```

```{r Protein Counts}

protein_counts_by_replicate <- function(protein.summarized.experiment){
  
  long <- get_long_protein_intensity(protein.summarized.experiment)

  dt <- long[, .N, by = .(Condition, Replicate)]
  dt[, Run := str_c(Condition, Replicate, sep = " - ")]
  p <- ggplot(dt, aes(x = as.factor(Run), y = N, color = Condition, label=Replicate)) +
    geom_segment( aes(x=as.factor(Run), xend=as.factor(Run), y=0, yend=N), color="skyblue") +
    geom_point(size=2, alpha=0.9) +
    coord_flip() +
    theme_minimal() +
    scale_x_discrete("Condition - Replicate") +
    scale_y_continuous("# Identifications") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.2),
          panel.grid.major.y = element_blank(),
          panel.border = element_blank(),
          axis.ticks.y = element_blank()
    )
  
  p
}

protein_counts_by_replicate(protein.summarized.experiment)
```

# Processing

We need to perform the following steps:

1. log transform


** split into binaries ** 

2. filter data (0.5 in at least one group for comparison)
3. Imputation

```{r Step 1.}

# Step 1. Get Long form of experiment
prepare_prot_int <- function(protein.summarized.experiment){
  
  prot.int <- get_long_protein_intensity(protein.summarized.experiment)
  prot.int[, Imputed := 0L]
  prot.int[Intensity == 0, Imputed := 1L]
  prot.int[, log2NInt := 0.0]
  prot.int[Intensity > 0 , log2NInt := log2(Intensity)]
  prot.int
}



prot.int <- prepare_prot_int(protein.summarized.experiment)
```

```{r impute LFQ data func}
#' 
#'
#' This function does MNAR imputation
#'
#' @param myQuantDT quantification data
#' @param id_type the id column of myQuantDT that indicates
#' @param int_type the column of myQuantDT to be imputed
#' @param f_imputStDev The Standard Deviation parameter for MNAR Imputation
#' @param f_imputePosition The Position parameter for MNAR Imputation
#' @return quantification data with missing values imputed
#' @examples
#'  dt_int <- impute_lfq(myQuantDT = dt_int,
#'  id_type = "id",
#'  int_type = "log2NInt", #log2Intensity
#'  0.3,
#'  1.8,
#'  )
#' @export impute_lfq
impute_lfq <- function(myQuantDT,
                       id_type,
                       int_type,
                       f_imputeStDev = imputeStDev,
                       f_imputePosition = imputePosition) {

  myQuantDT[, int_impute := get(int_type)]
  myQuantDT <- myQuantDT[, colnames(myQuantDT) != int_type, with = F]
  impute.StdDev <-
    f_imputeStDev * myQuantDT[Imputed == 0, sd(int_impute)]
  impute.position <-
    myQuantDT[Imputed == 0, mean(int_impute)] - f_imputePosition * myQuantDT[Imputed == 0, sd(int_impute)]
  set.seed(255)
  myQuantDT[Imputed == 1, int_impute := rnorm(.N, (impute.position), (impute.StdDev))]

  # Add columns for centered and centered + scaled intensities
  myQuantDT[, nRLE := scale(int_impute, center = TRUE, scale = FALSE), by = .(get(id_type))]
  myQuantDT[, z_norm := scale(int_impute, center = TRUE, scale = TRUE), by = .(get(id_type))]

  setnames(myQuantDT, "int_impute", int_type)

  return(myQuantDT)
}
```

```{r Step 2.}


imputeStDev = 0.3
imputePosition = 1.8

prot.int <- impute_lfq(prot.int, 
                     id_type = "ProteinId", 
                     int_type = "log2NInt",
                     imputeStDev,
                     imputePosition)


```

```{r}

prot.int[, RunId := str_c(Condition, Replicate, sep = ".")]
results.quant <- limma_stats_fun(
  ID_type = "ProteinId",
  int_type = "log2NInt",
  condition_col_name = "Condition",
  run_id_col_name = "RunId",
  rep_col_name = "Replicate",
  funDT = prot.int
)

results.quant


rowData(protein.summarized.experiment) = merge(rowData(protein.summarized.experiment), results.quant, by = "ProteinId", all.x = T)

```

```{r limma stats function}

library(Biobase)
library(limma)
library(data.table)

limma_stats_fun <- function(ID_type,
                            int_type,
                            condition_col_name,
                            run_id_col_name,
                            rep_col_name,
                            funDT,
                            pairwise.comp = NULL,
                            all.comparisons = TRUE,
                            fix_distr = FALSE) {


  if (all.comparisons) {
    comination_mat <- combn(x = funDT[, unique(get(condition_col_name))], 2)
    pairwise.comp <- foreach (i = 1:ncol(comination_mat)) %do% {
      return(data.table(
        left = comination_mat[1,i],
        right = comination_mat[2,i]
      ))
    }
    pairwise.comp <- rbindlist(pairwise.comp)
  }


  funDT <- funDT[str_order(get(run_id_col_name), numeric = T)]
  funDT[, ID := str_c("ID.", get(ID_type))]

  # Filter for IDs that are not present in at least one experiment
  filterDT <- unique(funDT[, .(get(condition_col_name), get(run_id_col_name))])[, .(max_count = .N), by = .(V1)]
  filterDT <- merge(funDT, filterDT, by.x = condition_col_name, by.y = "V1", all.x = T)
  filterDT <- filterDT[Imputed == 0, .(count_rep = .N, 
                                       max_count = max(max_count, na.rm = T)), 
                       by = c(condition_col_name, "ID")][, repPC := count_rep/max_count]

  isPresent <- filterDT[repPC >= 0.5, unique(ID)]
  funDT <- funDT[ID %in% isPresent]

  fun.formula <- as.formula(str_c("ID ~ ", run_id_col_name))


  int_matrix <-
    dcast.data.table(funDT, fun.formula, value.var = int_type)
  int_matrix <- int_matrix[str_order(ID, numeric = T)]
  intrawnames <- int_matrix[, ID]
  intcolnames <- colnames(int_matrix[, 2:ncol(int_matrix)])
  intcolnames <- str_sort(intcolnames, numeric = TRUE)

  int_matrix <- as.matrix(int_matrix[, intcolnames, with = FALSE])
  rownames(int_matrix) <- intrawnames

  ### Imputed value mask matrix ------
  imputed_matrix <-
    dcast.data.table(funDT, fun.formula, value.var = "Imputed")
  imputed_matrix <- imputed_matrix[str_order(ID, numeric = T)]
  imp_mat_rawnames <- imputed_matrix[, ID]
  imp_mat_colnames <- colnames(imputed_matrix[, 2:ncol(imputed_matrix)])
  imp_mat_colnames <- str_sort(imp_mat_colnames, numeric = TRUE)

  imputed_matrix <- as.matrix(imputed_matrix[, imp_mat_colnames, with = FALSE])
  rownames(imputed_matrix) <- imp_mat_rawnames
  isZ <- imputed_matrix == 1

  sample_dt <- as.data.frame(unique(funDT[, .(
    run_id = get(run_id_col_name),
    condition = get(condition_col_name),
    Replicate = get(rep_col_name)
  )]))
  rownames(sample_dt) <- sample_dt$run_id
  
  
  feature_dt <- data.frame(ID = rownames(int_matrix), otherinfo = NA)

  rownames(feature_dt) <- feature_dt$ID

  # Create ExpressionSet object
  eset <- ExpressionSet(
    assayData = int_matrix,
    phenoData = AnnotatedDataFrame(sample_dt),
    featureData = AnnotatedDataFrame(feature_dt)
  )

  design.mat <- model.matrix(~ 0 + condition,
                             data = pData(eset))
  myContrasts = NULL
  for (irow in 1:pairwise.comp[, .N]) {
    left <- pairwise.comp[irow, left]
    right <- pairwise.comp[irow, right]

    myContrasts = c(myContrasts,
                    str_c("condition", left, " - ", "condition", right))
  }


  contrast.matrix <- eval(as.call(c(
    as.symbol("makeContrasts"),
    as.list(myContrasts),
    levels = list(design.mat)
  )))

  fit <- lmFit(eset, design.mat)

  # exper.cond <- "UPS1"
  # fix_distr <- TRUE
  if (fix_distr) {
    for (exper.cond in pairwise.comp[, c(left, right)]) {
      Runs <- pData(eset)[pData(eset)$condition == exper.cond, run_id_col_name]
      i <- which(rowSums(isZ[,colnames(isZ) %in% Runs]) == length(Runs))
      eset_fix <- exprs(eset[i,])
      eset_fix[,colnames(isZ) %in% Runs] <- NA
      fit3 <- lmFit(eset_fix, design.mat)
      fit$sigma[i] <- fit3$sigma
      fit$df.residual[i] <- fit3$df.residual
    }
  }
  fit2 <- contrasts.fit(fit, contrasts = contrast.matrix)
  fit2 <- eBayes(fit2, robust = TRUE, trend = TRUE)

  stats <-
    topTable(fit2,
             number = nrow(fit2),
             sort.by = "none"
    )
  stats <- as.data.table(stats)
  stats <- stats[, .(ID, AveExpr, F, adj.P.Val)]
  #ipair = 1
  #### pairwise comparisons
  for (ipair in 1:pairwise.comp[, .N]) {
    #print(ipair)
    subsecting <- funDT[get(condition_col_name) %in% pairwise.comp[ipair, c(left, right)], unique(get(run_id_col_name))]

    # Filter for IDs that are not present in at least one experiment in pairwise manner
    isPresent <- filterDT[get(condition_col_name) %in% pairwise.comp[ipair, c(left, right)] & repPC >= 0.5, unique(ID)]

    if (length(isPresent) > 0) {
      eset_pair <- eset[rownames(eset) %in% isPresent, colnames(eset) %in% subsecting]



      design.mat <- model.matrix(~ 0 + condition,
                                 data = pData(eset_pair))


      myContrasts = NULL
      left <- pairwise.comp[ipair, left]
      right <- pairwise.comp[ipair, right]
      myContrasts = c(myContrasts,
                      str_c("condition", left, " - ", "condition", right))
      contrast.matrix <- eval(as.call(c(
        as.symbol("makeContrasts"),
        as.list(myContrasts),
        levels = list(design.mat)
      )))

      fit <- lmFit(eset_pair, design.mat)
      fit2 <- contrasts.fit(fit, contrasts = contrast.matrix)
      fit2 <- eBayes(fit2, robust = TRUE, trend = TRUE)

      s_dt <-
        as.data.table(topTable(
          fit2,
          number = nrow(fit2),
          sort.by = "p",
          confint = 0.95,
          coef = myContrasts
        ))
      s_dt <- s_dt[, .(ID, logFC, CI.L, CI.R, P.Value, adj.P.Val)]
      #q_vals <- qvalue(s_dt[, P.Value])
      #s_dt[, Q.Value := q_vals$qvalues]

      comparison <- str_replace_all(myContrasts, "condition", "")
      colnames(s_dt)[colnames(s_dt) != "ID"] <-
        str_c(colnames(s_dt)[colnames(s_dt) != "ID"], comparison, sep = " ")
      stats <- merge(stats, s_dt, by = "ID", all = T)
    }


  }





  stats[, ID := str_replace_all(ID, "ID.", "")]
  setnames(stats, "ID", ID_type)
  return(stats)
}
```

```{r Construct Summarized.de objects}
get_comparison_strings <- function(results.quant){
  cols <- colnames(results.quant)
  cols <- cols[grepl("logFC ", colnames(results.quant))]
  comparison.strings <- gsub("logFC ", "", cols)
  comparison.strings
}
comparison.strings <- get_comparison_strings(results.quant)
unique(prot.int$Condition)
```

```{r Generic Discovery Pipeline}

run_generic_discovery_pipeline <- function(protein.summarized.experiment){
  prot.int <- prepare_prot_int(protein.summarized.experiment)
  prot.int <- impute_lfq(prot.int, 
                         id_type = "ProteinId", 
                         int_type = "log2NInt",
                         imputeStDev,
                         imputePosition)
  prot.int[, RunId := str_c(Condition, Replicate, sep = ".")]
  results.quant <- limma_stats_fun(ID_type = "ProteinId",
                                   int_type = "log2NInt",
                                   condition_col_name = "Condition",
                                   run_id_col_name = "RunId",
                                   rep_col_name = "Replicate",
                                   funDT = prot.int)
  
  rowData(protein.summarized.experiment) = merge(rowData(protein.summarized.experiment), 
                                                 results.quant, by = "ProteinId", all.x = T)
  
  protein.summarized.experiment
}


protein.summarized.experiment <- run_generic_discovery_pipeline(protein.summarized.experiment)
```

```{r}
rowData(protein.summarized.experiment)
```

# Write Output Tables


[ {
[
	{
		"conditionComparison": "Kidney - Muscle",
		"fdrLimit": 0.0164485444835632,
		"data": [
}]
	{
		"ProteinGroupId": "999",
		"ProteinId": "Q61792",
		"GeneName": "Lasp1",
		"ProteinDescription": "LIM and SH3 domain protein 1",
		"FastaHeaders": "sp|Q61792|LASP1_MOUSE LIM and SH3 domain protein 1 OS=Mus musculus OX=10090 GN=Lasp1 PE=1 SV=1",
		"ProteinQValue": 0,
		"ProteinScore": 66.98,
		"PValue": 3.207577361745e-10,
		"AdjustedPValue": 3.63871147493472e-09,
		"FoldChange": -1.6721318436707,
		"ConfLow": -1.93675153817554,
		"ConfHigh": -1.40751214916586
	}
	
```{r}

filter_stats_table_on_comparison <- function(statistics.table, comparison){
  example_col = str_c("P.Value ",comparison)
  stopifnot(example_col %in% colnames(statistics.table))
  statistics.table <- 
  
  # filter rows on valid statistics  
  statistics.table[!is.na(statistics.table[[example_col]]),]
  
  # filter columns for ProteinId and condition
  
  statistics.columns <- str_c(c("logFC ","adj.P.Val ",
                                "P.Value ",
                                "CI.L ", "CI.R "), 
                              comparison)

  stopifnot(statistics.columns %in% colnames(statistics.table))
  
  statistics.table <- statistics.table[,c("ProteinId",statistics.columns)]
  
  colnames(statistics.table) <- gsub(str_c(" ",comparison), "",colnames(statistics.table))
    
  statistics.table
}

comparison = "sample2 - sample4"
comparison.statistics <- rowData(protein.summarized.experiment)
comparison.statistics <- filter_stats_table_on_comparison(comparison.statistics, comparison)
comparison.statistics
```
	
```{r}
#comparison.statistics <- as.data.table(comparison.statistics)
fdr_line <- max(comparison.statistics[comparison.statistics$adj.P.Val<=0.05,]$P.Value,na.rm = T)
fdr_line

#conditions <- unique(prot_int$condition)
#condition1 <- get_condition_string(conditions, comparisons[i], position = 1)
#condition2 <- get_condition_string(conditions, comparisons[i], position = 2)
#conditions <- unique(protein.summarized.experiment$Condition)
#
```
```{r}

fill_out_missing_columns <- function(comparison.statistics){
  
  columns.possible=  c("ProteinId","GeneId","Description",
                        "logFC","adj.P.Val","P.Value",
                         "CI.L", "CI.R")
  
  columns.present = intersect(columns.possible, colnames(comparison.statistics))
  columns.absent <- columns.possible[!(columns.possible %in% columns.present)]
  comparison.statistics[,columns.absent]<-NA
  
  comparison.statistics
}
rename_comparison_statistics_export <- function(comparison.statistics){
  
  comparison.statistics = as_data_frame(comparison.statistics) %>% 
    dplyr::rename(
      ProteinId = ProteinId,
      GeneName = GeneId,
      Description = Description,
      PValue = P.Value,
      AdjustedPValue = adj.P.Val,
      FoldChange = logFC,
      ConfLow = CI.L, 
      ConfHigh = CI.R
    )

  comparison.statistics
} 

comparison.statistics <- fill_out_missing_columns(comparison.statistics)
comparison.statistics <- rename_comparison_statistics_export(comparison.statistics)
comparison.statistics
```


```{r}
library(jsonlite)

x = list(conditionComparison = unbox(comparison),
    		 fdrLimit =  unbox(fdr_line),
    		 data = as.data.table(comparison.statistics))

write_json(x ,"test2.json", digits = NA, na = "null")
```

```{r}
get_protein_viz <- function(prot, prot_int, output_folder){
  

  # Get name of columns and comparisons from protein table
  adj_pval_cols <- grep("adj.P.Val", colnames(prot), value = TRUE)
  adj_pval_cols <- adj_pval_cols[adj_pval_cols != "adj.P.Val"]
  pval_cols <- grep("P.Value", colnames(prot), value = TRUE)

  comparisons <- str_remove(pattern = "P.Value ", string = pval_cols)

  adj_test_pre <- "adj.P.Val " # unique(str_extract(pattern = "adj.P.Val ", string = pval_cols))
  test_pre <- "P.Value " # unique(str_extract(pattern = "adj.P.Val ", string = pval_cols))

  estimate_pre <- "logFC " 
  confLow_pre <- "CI.L "  colnames(prot), value = TRUE)))
  confHigh_pre <- "CI.R " 
 
   FUN <- function(j, DT, comparison_pair) {
    #debug
    # j = 1
    # DT = copy(dt)
    # comparison_pair = comparison_pair

    ID_num <- DT[j, ProteinGroupId]
    return(
      list(
        ProteinGroupId = ID_num,
        ProteinId = DT[j, ProteinId],
        GeneName = DT[j, gene_name],
        ProteinDescription = DT[j, protein_description],
        FastaHeaders = DT[j, FastaHeaders],
        ProteinQValue = DT[j, ProteinQValue],
        ProteinScore = DT[j, ProteinScore],
        PValue = DT[j, PValue],
        AdjustedPValue = DT[j, FDR],
        FoldChange = DT[j, FoldChange],
        ConfLow = DT[j, ConfLow],
        ConfHigh = DT[j, ConfHigh]
      )
    )
  }

  to_our <- list()

  #i = 1
  for (i in 1:length(comparisons)) {

    pval_col = str_c(test_pre, comparisons[i])
    adj_pval_col = str_c(adj_test_pre, comparisons[i])
    estimate_col = str_c(estimate_pre, comparisons[i])
    confLow_col = str_c(confLow_pre, comparisons[i])
    confHigh_col = str_c(confHigh_pre, comparisons[i])

    dt <- copy(prot[, .(
      ProteinGroupId = id,
      ProteinId,
      FastaHeaders = fasta_headers,
      ProteinQValue = `q-value`,
      ProteinScore = score,
      PValue = get(pval_col),
      FDR = get(adj_pval_col),
      FoldChange = get(estimate_col),
      ConfLow = get(confLow_col),
      ConfHigh = get(confHigh_col),
      gene_name,
      protein_description

    )])

    #dt[!(is.na(TestPValue)), PValue := 1]
    #dt[!(is.na(TestPValue)) & TestPValue > 0, PValue := TestPValue ]
    #min_pval <- dt[PValue > 0, min(PValue, na.rm = T)]
    #dt[!(is.na(PValue)) & TesPValue == 0, PValue := min_pval / 10]

    pc_fdr_limit <- dt[FDR <= 0.05, max(PValue, na.rm = T)]

    
    conditions <- unique(prot_int$condition)
    condition1 <- get_condition_string(conditions, comparisons[i], position = 1)
    condition2 <- get_condition_string(conditions, comparisons[i], position = 2)
    
    #dt_int <- replicate_count_dt[condition %in% comparison_pair]

    pair_wise_data_list <- parLapply(cl, 1:dt[, .N], FUN, DT=dt, 
                                     comparison_pair=c(condition1, condition2))

    to_our[[i]] <- list(
      conditionComparison = comparisons[i],
      up.condition = condition1,
      down.condition = condition2,
      fdrLimit = pc_fdr_limit,
      data = pair_wise_data_list
    )

  }
  write_json(to_our, path = file.path(output_folder, "protein_viz.json"), pretty = FALSE, auto_unbox = TRUE, digits = NA)

```


```{r condition name parsing}

# use literal string match to find condition name in comparison string
#' @export detect_condition_string
detect_condition_string <- function(conditions, string){
  for (condition in conditions){
    if (grepl(condition, string, fixed = T)){
      return(condition)
    } 
  }
  stop("Couldn't match a condition the assay data and comparisons")
}

# use literal string match to return first or second condition in string
get_condition_string <- function(conditions, comparison, position = 1){
  
  stopifnot((position == 1) | (position == 2))
  
  match1 <- detect_condition_string(conditions,comparison) 
  comparison_remainder = gsub(match1, "",comparison, fixed = T)
  match2 <- detect_condition_string(conditions, comparison_remainder)   
  
  stopifnot(match2 != match1)
  
  position_match_1 <- gregexpr(pattern = match1,
                               comparison,
                               fixed = T)[[1]][1]
  
  position_match_2 <- gregexpr(pattern = match2,
                               comparison,
                               fixed = T)[[1]][1]
  if (position == 1){ # give the first match
    if (position_match_1 > position_match_2){
      return(match2)
    } else {
      return(match1)
    }
  } else if (position == 2) { # give the second match
    if (position_match_2 > position_match_1){
      return(match2)
    } else {
      return(match1)
    }
  }
  stop("Something went wrong, shouldn't be accessible. ")
}
```

